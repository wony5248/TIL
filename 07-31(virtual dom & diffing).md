# virtualDom & diffing 알고리즘
#### DOM
* DOM은 Document Object Model의 약자로 브라우저가 HTML 문서를 해석하는 방식을 의미한다.
* HTML은 말 그대로 태그들로 이루어진 텍스트인데, 이를 브라우저가 해석할 수 있도록 이해하기 편한 객체 트리 방식으로 변환하는 것이고 이는 DOM tree라 불린다.
* 브라우저가 HTML Parser를 통해 HTML 태그들을 DOM tree형식으로 만들고 CSS를 적용하여 RenderTree를 생성하게 된다.
* RenderTree 생성되고 난 뒤 reflow와 repaint 과정등, 브라우저가 각 노드들의 좌표를 계산하고 색을 입히는 과정을 거친후에 화면에 그려내게 된다.
#### VirtualDOM
* DOM 차원에서의 더블 버퍼링 개념을 의미한다.
* 중간에 가상의 DOM을 두어 개발의 편의성과 성능을 개선하도록 해준다.
* 개발자가 DOM을 조작할때 직접 DOM을 조작하는 것이 아닌 가상의 DOM을 조작하고 이 가상의 DOM에 대한 변화를 한번에 DOM에 적용시키는 방식이다.
#### VirtualDOM의 등장 배경
* 예전에 정적인 텍스트 파일들과 간단한 css만 제공하면 되었었던 웹앱이 지금은 반응형으로 바뀌면서 비교할 수 없을 만큼 많은 DOM조작을 요구하게 되었다.
* 브라우저는 API를 통해 DOM을 조작하는 방식들을 제공합니다. 하지만 문제는 DOM을 직접 조작하는 행위는 브라우저로 하여금 각 조작마다 reflow 와 repaint를 수반하게 한다는 점
* 예를 들어 DOM 조작을 30번 실행하는 코드가 있다고 했을 때, 만약 이 코드가 브라우저의 DOM을 직접 조작하도록 설계되었다면, 브라우저는 실제로 사용자가 보기에 그렇게 많은 내용이 바뀌지 않음에도 불구하고 30번이나 모든 노드들의 위치와 css를 다시 계산하고 그려내야 한다는 것을 의미한다.
* Virtual DOM은 브라우저가 해석하는 대상이 아니기 때문에, 변경되어도 브라우저가 repaint, reflow등의 연산을 수행하지 않는다.
*  DOM을 30번 조작하는 경우가 생긴다면 virtual DOM은 이를 Batch Queue에 모아둔 후에, 이를 모두 처리하고 나서 한꺼번에 업데이트 사항을 브라우저의 DOM에 반영하게 됩니다. 결과적으로는 1번만 DOM을 다시 그리고도 30번의 업데이트 사항을 모두 반영할 수 있게 되는 것이다.
#### Diffing 알고리즘
* React의 Render함수는 jsx문법에 맞는 React Element를 반환한다.
* 이때, 상태가 변하거나 프로퍼티가 변해서 DOM을 업데이트해야 하는 경우에 변경된 부분만 감지해서 바뀐 부분만 업데이트 하는 방식을 취하게 되는데, 이 변경된 부분을 감지하는 방법을 Diffing Algorithm이라고 한다.
* "비교"란 Virtual DOM 끼리의 비교를 의미하며, React는 이전상태와의 비교를 위해 항상 이전 상태의 Virtual DOM의 사본을 유지한다.
* DOM은 트리 구조이기 때문에 변경된 부분을 감지하기 위해서는 트리 구조를 비교해야 합니다. 일반적인 트리 구조의 비교는 O(n^3)의 시간이 소요되는 것으로 알려져 있어 비효율적으로 보이지만, React는 이를 Heuristic한 방식을 사용해서 O(n)의 시간에 해결한다.
* 비슷한 컴포넌트는 트리 내에 동일한 계층에 위치할 것이다. 따라서 이 컴포넌트가 갑자기 부모가 바뀌거나 하는 일이 없다고 가정하고 같은 계층에 있는 컴포넌트들끼리만 비교하자
* 하나의 jsx 태그 (react가 지원하는 엘리먼트 태그 방식)은 자바스크립트 객체로 구성되어 있습니다. 이 객체에는 해당 객체가 React의 virtual DOM의 요소임을 확인해주는 symbol값과, 각각의 virtual DOM을 고유하게 구분하는 key값이 들어간다.
* 리액트는 이 키들의 비교를 통해 리스트의 요소가 추가되거나 삭제되었을때, 해당 내용을 빠르게 감지하고 반영할 수 있다.
* 두 개의 트리를 비교할 때, React는 두 엘리먼트의 루트(root) 엘리먼트부터 비교합니다. 이후의 동작은 루트 엘리먼트의 타입에 따라 달라집니다.
  * 엘리먼트의 타입이 다른 경우
    * 두 루트 엘리먼트의 타입이 다르면, React는 이전 트리를 버리고 완전히 새로운 트리를 구축
    * 트리를 버릴 때 이전 DOM 노드들은 모두 파괴한다.
  * DOM 엘리먼트의 타입이 같은 경우
    * 같은 타입의 두 React DOM 엘리먼트를 비교할 때, React는 두 엘리먼트의 속성을 확인하여, 동일한 내역은 유지하고 변경된 속성들만 갱신한다.
    * DOM 노드의 처리가 끝나면, React는 이어서 해당 노드의 자식들을 재귀적으로 처리합니다.
  * 같은 타입의 컴포넌트 엘리먼트
    * 컴포넌트가 갱신되면 인스턴스는 동일하게 유지되어 렌더링 간 state가 유지된다.
    * React는 새로운 엘리먼트의 내용을 반영하기 위해 현재 컴포넌트 인스턴스의 props를 갱신한다.
    * 다음으로 render() 메서드가 호출되고 비교 알고리즘이 이전 결과와 새로운 결과를 재귀적으로 처리한다.
* 자식에 대한 재귀적 처리
  * DOM 노드의 자식들을 재귀적으로 처리할 때, React는 기본적으로 동시에 두 리스트를 순회하고 차이점이 있으면 변경을 생성한다.
  * React는 종속 트리를 그대로 유지하는 대신 모든 자식을 변경합니다. 이러한 비효율은 문제가 될 수 있습니다.
  * Keys
    * 이러한 문제를 해결하기 위해, React는 key 속성을 지원합니다. 자식들이 key를 가지고 있다면, React는 key를 통해 기존 트리와 이후 트리의 자식들이 일치하는지 확인한다.
