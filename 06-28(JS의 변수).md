# JavaScript의 변수 선언
* var, let, const
* var와 let의 경우 재할당이 가능하지만, const의 경우는 재할당이 불가능 하다.
#### 호이스팅
* 호이스팅은 변수선언을 해당 스코프의 최상단으로 끌어올리는 것이 아니다.
* 호이스팅은 코드가 실행되기 전 변수 선언이 해당 스코프의 최상단으로 끌어올려진 것 처럼 보이는 현상이다.
* 자바스크립트 엔진은 코드를 실행하기 전 실행 가능한 코드를 형상화하고 구분하는 과정(*실행 컨텍스트를 위한 과정)을 거친다.
* 자바스크립트 엔진은 코드를 실행하기 전 실행 컨텍스트를 위한과정에서 모든 선언(var, let, const, function, class)을 스코프에 등록한다.
* 코드 실행 전 이미 변수선언/함수선언이 저장되어 있기 때문에 선언문보다 참조/호출이 먼저 나와도 오류 없이 동작한다.
* (정확히는 var 키워드로 선언한 변수와 함수 선언문일 경우 오류 없이 동작한다. 이는 선언이 파일의 맨 위로 끌어올려진 것 처럼 보이게 한다.)
* 실행 컨텍스트는 실행 가능한 코드가 실행되기 위해 필요한 환경을 의미하고 실행되기전 이러한 실행 컨텍스트 과정(코드를 구분하는 과정)을 거친다.
#### 변수 호이스팅
* 자바스크립트의 모든 선언에는 호이스팅이 일어난다.
* let, contx, class를 이용한 선언문은 호이스팅이 일어나지 않은 것처럼 동작한다.
* let 으로 선언된 변수는 스코프의 시작에서 변수의 선언까지 일시적 사각지대에 빠진다.
* 호이스팅이 파일의 맨 위로 끌어올려진 것 같은 현상을 의미할 때 선언문 이전에 참조해서 에러를 발생시킨다고 호이스팅이 일어나지 않은 것은 아니라는 의미이다.
```
console.log(hello);
let hello = 'hello'; => 참조에러 발생

console.log(hello);
let hello = 'hello'; => undefined 출력

foo1(); // 함수 선언문에서는 호이스팅 일어난다.
foo2(); // 함수 표현식이라서 호이스팅 안된다.
function foo1() {
  console.log('Hello');
}
var foo2 = function() {
  console.log('world');
}
```
#### 변수의 생성과정
1. 선언단계
 * 변수를 실행 컨텍스트 변수 객체에 등록
 * 이 변수 객체는 스코프가 참조하는 대상이 된다.
2. 초기화 단계(Initialization phase)
 * 변수 객체에 등록된 변수를 위한 공간을 메모리에 확보한다.
 * 이 단계에서 변수는 undefined로 초기화 된다.
3. 할당 단계(Assignment phase)
 * undefined로 초기화된 변수에 실제 값을 할당한다
