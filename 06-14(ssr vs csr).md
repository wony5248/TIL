# SSR vs CSR
#### SSR 이란?
* ServerSideRendering의 약자로 서버쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식이다.
#### SSR의 단계
1. User가 website에 요청을 보냄
2. Server는 Ready to Render 즉시 렌더링 가능한 html 파일을 만든다.
3. 클라이언트에 전달되는 순간 이미 rendering 준비가 되어 있기 때문에 HTML은 즉시 렌더링 된다. (JavaScript가 읽히기 전이라 조작은 불가능)
4. 클라이언트가 JavsScript를 다운받는다.
5. 다운받아지는 사이에 User는 컨텐츠를 볼 수 있지만 조작은 불가능 상태 사용자의 조작을 기억한다.
6. 브라우저가 JavaScript 프레임워크를 실행한다.
7. JS까지 성공적으로 컴파일 된 이후에 기억하고 있던 사용자 조작을 실행하고 상호작용이 가능해진다.
![asdf](https://github.com/wony5248/TIL/assets/48344143/99b8e46b-e032-48be-8460-779d6469b212)
#### CSR 이란?
* ClientSideRendering의 약자로 클라이언트 쪽에서 렌더링이 일어난다.
#### CSR의 단계
1. User가 Website 요청을 보냄.
2. CDN이 HTML 파일과 JS로 접근할 수 있는 링크를 클라이언트로 보낸다.
  * CDN : aws의 cloudflare를 생각하면 됨. 엔드 유저의 요청에 '물리적'으로 가까운 서버에서 요청에 응답하는 방식
3. 클라이언트는 HTML과 JS를 다운로드 받는다.
  * (이때 SSR과 달리 유저는 아무것도 볼 수 없다.😡)
4. 다운이 완료된 JS가 실행된다. 데이터를 위한 API가 호출된다.
  * (이때 유저들은 placeholder를 보게된다. )
5. 서버가 API로부터의 요청에 응답한다.
6. API로부터 받아온 data를 placeholder 자리에 넣어준다. 이제 페이지는 상호작용이 가능해진다.
![fghfghf](https://github.com/wony5248/TIL/assets/48344143/c9c47bce-58cb-4165-a183-ba96bf98317b)
#### CSR의 장단점
* 장점
  * 네이티브 앱과 비슷한 빠른 인터랙션 구현 가능
  * 후속 페이지 로드시간이 빠르다.
  * 서버를 호출할 때마다 전체 UI를 로드할 필요가 없다.
* 단점
  * 첫 페이지 로딩 속도가 서버사이드 렌더링에 비해 다소 느리다.
  * SEO에 친화적이지 않다.
  * 페이지 메타데이터의 변경을 위한 추가 조치가 필요하다.
  * UX가 서버사이드 렌더링에 비해 좋지 않다. (html, javascript 다운받고 실행하는 동안 빈페이지 보임)
  * 클라이언트의 하드웨어 및 소프트웨어에 많은 의존성을 지닌다.
#### SSR의 장단점
* 장점
  * 초기 페이지 로드시간이 빠르다.
  * 서버에서 페이지 로직을 수행하면 클라이언트에 JavaScript를 보내지 않아도 되기에 TTI를 빠르게 수행 가능
  * SEO에 친화적이다.
  * 클라이언트 하드웨어 및 소프트웨어에 영향 덜 받는다.
* 단점
  * 페이지 이동시마다 페이지 생성하기에 TTFB가 느리다.
  * 페이지 로드가 너무 무거울 경우 UX가 좋지 않아질 수 있다.
  * 서버는 요청이 올때마다 HTMl을 생성하기에 CDN수준에서의 컨텐츠 캐시가 되지 않는다.
  * 서버의 호스팅이 필요하다.
  * CSR에 비해 더 많은 개발 공수가 든다.
#### SSG
* SSR처럼 서버로부터 완성된 HTML을 가져오지만 빌드타입에 HTML 파일을 생성한다.
#### SSG 동작 방식
1. 사용자가 웹 페이지를 방문하면(request), 엣지 캐싱(edge caching)된 HTML 클라이언트로 반환해 준다.
2. 브라우저는 HTML을 다운로드하고 최종 사용자가 사이트를 볼 수 있도록 한다.
#### SSG 장단점
* 장점
  * 빌드타임에 HTML이 생성되기에 빠른 FP, FCP, TTI를 제공한다.
    * FP: 첫 픽셀이 그려지는 시점
    * FCP: 페이지가 로드되기 시작하고 컨텐츠의 일부가 렌더링 될 때까지의 시간
    * FMP: 페이지의 주요 컨텐츠들을 화면에 렌더링 하기 시작하는 순간
    * TTI: 웹 페이지가 완전히 상호작용이 가능하게 되는 시점
    * FID: 사용자가 페이지와 처음 상호작용한 순간 부터 브라우저가 실제로 이벤트 핸들러 처리를 시작할 수 있는 시간까지의 시간
    * TBT: 총 차단 시간(TBT) 메트릭은 메인 스레드가 입력 응답을 막을 만큼 오래 차단되었을 때 First Contentful Paint(최초 콘텐츠풀 페인트, FCP)와 Time to Interactive(상호 작용까지의 시간, TTI) 사이 총 시간을 측정합니다.
    * LCP: 페이지에서 가장 용량이 큰 컨텐츠가 표시되는 시점
    * CLS: 페이지가 로드되기 시작하는 시점과 lifecycle 상태가 숨김으로 변경되는 시점 사이에 발생하는 모든 예기치 않은 레이아웃 이동의 누적 점수를 측정한다
    * TTFB: 서버에서 데이터의 첫 번째 바이트가 도착하는 시점 - 서버 성능과 직결
  * 요청마다 생성하는 것이 아니기에 빠른 TFB를 달성 가능
  * SEO에 친화적
* 단점
  * 모든 URL에 대해 개별 HTML 파일을 생성해야 한다.
#### Universal Rendering
* SSR을 통해 빠른 FCP를 구현한 다음 rehydration이라는 기술을 통해 다시 rendering 하는 방식
#### Universal Rendering 장단점
* 장점
  * SSR을 통해 빠른 FCP를 구현하므로 CSR의 단점 개선 가능
* 단점
  * 별도의 서버가 필요하며 러닝커브가 높다
  * 페이지가 빨리 로드되며 빠른것처럼 보이지만 javascript가 실행되고 이벤트 핸들러가 적용될때가지 상호작용이 되지 않는다.
#### ISR
* 런타임 중에 정적 페이지를 만들고 업데이트 할 수 있게 해주는 SSR, SSG의 하이브리드 솔루션이다.
#### ISR 동작 방식
1. 사용자가 웹 페이지를 방문하면(request), 요청에 의해 페이지가 생성되지만 데이터가 오기를 기달려야하는 SSR과 달리 즉시 대체 페이지(fallback page)가 제공된다. 이 단계에서 대부분 placeholder 및 스캘래톤을 표시한다.
2. 데이터가 확인되면 최종 페이지가 캐시되고, 사용자는 SSG와 마찬가지로 캐시된 버전의 페이지를 받게 된다.
3. 재검증시에도 사용자는 먼저 캐시된 버즌을 받고 업데이트된 버번을 받는다. (캐싱 전략: Stale-while-revalidate)
#### SSG 장단점
* 장점
  * SSR과 달리 페이지가 즉시 제공되며 빠른 상호작용으로 UX가 좋아진다.
* 단점
  * 페이지 디자인에 따라 첫번째 의미있는 페인팅이 지연될 수 있다.
